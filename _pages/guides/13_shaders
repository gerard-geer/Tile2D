---
layout: featuredoc
title: Shaders in Tile2D
featuretitle: Shaders in Tile2D
permalink: /guides/shaders/
isShaderGuide: true
---

{::options parse_block_html="true" /}

Shaders in Tile2D
-----------------------
{: .floating-header}

Shaders are often a hassle. You have to load ASCII source code, send it to a secondary processing
unit, tell that unit to compile it, then tell the unit what its values should be and when to use it.

Tile2D shaders try to make things a little bit better.


Uniform Variables
--------------------------

Normally one needs to remember the exact name of a uniform as well as its type in order to set it
via one of the ```glUniformXX()``` functions. 

Tile2D abstracts this away via the *ShaderUniform* class. 

ShaderUniforms encapsulate two important datums: uniform variable location and type (via an emum).

This simplifies uniform updating to a single function call that passes in a value.

Shader objects store 

When using a custom shader, these uniform variables are defined and populated:

| ```uniform sampler2D fwdFB``` | The color buffer of the forward pass'' framebuffer. |
| ```uniform sampler2D defFB``` | The color buffer of the deferred pass' framebuffer. |
| ```uniform vec2 winResolution``` | The resolution of the window. |
| ```uniform vec2 fbResolution``` | The resolution of the renderer's framebuffers. |
| ```uniform float time``` | The time since the OpenGL context was created. |

When writing the shader, be sure to perform the composition:

```glsl
gl_FragColor.rgb = vec4( mix(fwdFB.rgb, defFB.rgb, defFB.a), 1.0 );
```

Beyond that, go wild!

In order to use your custom shader it must be added to the AssetManager, then you must call:

```cpp
void Renderer::setCustomShader(char * customCompositor);
```

| customCompositor | The key of the Shader to use. |

If the shader does not exist or is removed then the Renderer will default back to the stock shader.
If it has been removed, one must call ```setCustomShader()``` again to resume use.