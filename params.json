{
  "name": "Tile2D",
  "tagline": "A Tile-based 2D rendering engine.",
  "body": "# Tile2D\r\nA Tile-based 2D rendering engine.\r\n---------------------------------\r\nEver just want a decent way to just make a window, load some sprites and blit them?\r\nThis is for you. Ever want a 2D engine that's super light, but also highly capable?\r\nThis is also for you.\r\n\r\nFeatures\r\n------------\r\n- **PNG support.** It's a pretty good image format. Tile2D also autodetects alpha channels and optimizes on the presence\r\nor absence of an alpha channel.\r\n- **Targets OpenGL 2.1 (With FBO support).** Uses OpenGL 2.1 (GLSL 1.2) and its programmable pipeline for maximimum\r\ncompatibility.\r\n- **Passive parallax scrolling.** Parallax scrolling is deferred to the vertex shader. Just set a plane and that's it.\r\n- **Rotation.** Not too many sprite-based rendering libraries give you clear and simple rotation. (Also deferred to the vertex shader.)\r\n- **Extensive programability.** Custom shader code can be written for FwdTiles, DefTiles and the screen compositor (what combines both passes). Even further, you can extend the base Tile class to create whatever kind of Tile you want. Further yet, GLFW, GLEW, and OpenGL are all visible. Tile2D's encapsulated GLFW and OpenGL objects can all be accessed directly. Want to set a crazy GLFW window option, or change the OpenGL state to do some wild stuff? Nothing is stopping you.\r\n- **Deferred rendering and post processing.** With DefTiles you can write your own shader code, with access to the depth and color buffer of the forward rendering pass. Post-processed and deferred effects await!\r\n- **Proactive downsampling** The Renderer and Window have independent resolutions. Therefore you can render at lower\r\nresolutions such as ```256x240```(NES) or ```320x224```(Genesis) and have that great pixelated appearance.\r\nBetter yet Tiles are renderered at this resolution--not rendered then downsampled--so overdraw is kept to a minimum.\r\n- **Screenspace and normalized coordinate systems.** You can work in terms of pixels _or_ [-1,1].\r\n- **Automatic optimization.** Add Tiles in whatever order you want. They're sorted each frame to minimize overdraw and\r\nmaximize culling.\r\n- **Simplified window management.** Fullscreen rendering and resolution changing and OpenGL state management are all handled\r\nbehind the scenes. Want to go fullscreen or change resolution (of the window or framebuffers)? They're single function\r\ncalls.\r\n- **Profiling and debugging.** Tile2D can be built with several debug options that send extra output to ```stdout```. Want to see what Tiles are drawn each frame? What are your render times? The properties of the textures you've loaded? What the current screen and buffer resolutions are? This and more can be specified to be displayed.\r\n\r\nQuickstart\r\n----------\r\nIn just a few steps you can draw sprites to the screen.\r\n\r\n**Step 1:** Build. Download the source and run ```make``` to view the avaiable build options, then\r\nbuild with your preferred method. Make sure you have all the dependencies! (Listed below.)\r\n\r\n**Step 2:** Setup. Include the common header ```tile2d.h``` in your project, as well as the results of\r\nthe build. \r\n**Step 3:** Create a window! This creates a Tile2D Window, which is simply just a managed GLFW window. Also, it's also a good idea to store local pointers to the ```Renderer``` and ```AssetManager```.\r\n```c++\r\nWindow w = new Window();\r\nw->create(1000, 700, 256, 224, (char*)\"Tile2D Window\");\r\nRenderer * r = w->getRenderer();\r\nAssetManager * a = r->getAssetManager();\r\n```\r\n**Step 4:** Load some assets. Most Tiles need textures, and some even use custom shaders. In Tile2D, shaders and textures are\r\nconsidered to be Assets. Assets are stored in a key-value structure called an AssetManager, contained within the renderer itself.\r\n```c++\r\na->addNewTexture(\"puppy\", \"../ExampleAssets/puppy.png\");\r\n```\r\n**Step 5:** Create some Tiles. The Renderer contains several factory methods to easily create Tiles. Note though that there are more types of Tiles, and more options than apparent here.\r\n```c++\r\nSceneTile * st = r->makeSceneTile(.25, 0, PLANE_NEG_2, .5, .5, false, \"puppy\");\r\n```\r\n**Step 6:** Add the Tiles to the rendering queue. The rendering queue is an opaque list that automatically sorts the Tiles\r\nwhen added to minimize overdraw and maximize efficiency.\r\n```c++\r\nr->addToRenderQueue(BG_TILE, bg);\r\n```\r\n**Step 7:** Render! (In the style of GLFW)\r\n```c++\r\nglfwPollEvents();\r\nglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\r\nr->render(&window);\r\nglfwSwapBuffers(window.getWindow());\r\n++framecount;\r\n```\r\n\r\nDependencies\r\n--------------\r\n- **LibPNG** for image reading.\r\n- **GLFW** for OpenGL context creation.\r\n- **GLEW** for OpenGL extension wrangling.\r\n- **OpenGL 2.1 with ```GL_ext_framebuffer```** so we can have a programmable pipeline and framebuffer objects.\r\n- **Python** (2 or 3) for the script that consolidates shader code into a header file.\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}